//go:build ignore

// Package main is a code generator for NGF Policy methods.
// It generates the GetTargetRefs, GetPolicyStatus, and SetPolicyStatus methods
// for types marked with the +ngf:policy comment.
//
// Usage: go run main.go -types=TypeA,TypeB -package=v1alpha1 -targetref-single=TypeA -output=zz_generated.policymethods.go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"
	"text/template"
)

const (
	generatedFileHeader = `//go:build !ignore_autogenerated

// Code generated by policygen. DO NOT EDIT.

`
	generatedFileFooter = ""
)

var policyMethodsTemplate = template.Must(template.New("policyMethods").Parse(`
package {{.Package}}

import (
	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
)

{{- range .Policies}}

// GetTargetRefs implements the policies.Policy interface for {{.TypeName}}.
func (p *{{.TypeName}}) GetTargetRefs() []gatewayv1.LocalPolicyTargetReference {
{{- if .TargetRefSingle}}
	return []gatewayv1.LocalPolicyTargetReference{p.Spec.TargetRef}
{{- else}}
	return p.Spec.TargetRefs
{{- end}}
}

// GetPolicyStatus implements the policies.Policy interface for {{.TypeName}}.
func (p *{{.TypeName}}) GetPolicyStatus() gatewayv1.PolicyStatus {
	return p.Status
}

// SetPolicyStatus implements the policies.Policy interface for {{.TypeName}}.
func (p *{{.TypeName}}) SetPolicyStatus(status gatewayv1.PolicyStatus) {
	p.Status = status
}
{{- end}}
`))

type policyInfo struct {
	TypeName        string
	TargetRefSingle bool
}

type templateData struct {
	Package  string
	Policies []policyInfo
}

func main() {
	var (
		typesFlag           string
		packageFlag         string
		targetRefSingleFlag string
		outputFlag          string
	)

	flag.StringVar(&typesFlag, "types", "", "Comma-separated list of policy type names")
	flag.StringVar(&packageFlag, "package", "", "Package name for the generated file")
	flag.StringVar(&targetRefSingleFlag, "targetref-single", "", "Comma-separated list of types that have a single TargetRef (not TargetRefs)")
	flag.StringVar(&outputFlag, "output", "zz_generated.policymethods.go", "Output file name")
	flag.Parse()

	if typesFlag == "" {
		fmt.Fprintln(os.Stderr, "Error: -types flag is required")
		os.Exit(1)
	}
	if packageFlag == "" {
		fmt.Fprintln(os.Stderr, "Error: -package flag is required")
		os.Exit(1)
	}

	typeNames := strings.Split(typesFlag, ",")
	targetRefSingleTypes := make(map[string]bool)
	if targetRefSingleFlag != "" {
		for _, t := range strings.Split(targetRefSingleFlag, ",") {
			targetRefSingleTypes[strings.TrimSpace(t)] = true
		}
	}

	policies := make([]policyInfo, 0, len(typeNames))
	for _, typeName := range typeNames {
		typeName = strings.TrimSpace(typeName)
		if typeName == "" {
			continue
		}
		policies = append(policies, policyInfo{
			TypeName:        typeName,
			TargetRefSingle: targetRefSingleTypes[typeName],
		})
	}

	sort.Slice(policies, func(i, j int) bool {
		return policies[i].TypeName < policies[j].TypeName
	})

	data := templateData{
		Package:  packageFlag,
		Policies: policies,
	}

	var buf bytes.Buffer
	buf.WriteString(generatedFileHeader)

	if err := policyMethodsTemplate.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\n", err)
		fmt.Fprintln(os.Stderr, "Generated code:")
		fmt.Fprintln(os.Stderr, buf.String())
		os.Exit(1)
	}

	if err := os.WriteFile(outputFlag, formatted, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", outputFlag)
}
